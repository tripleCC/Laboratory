/* Copyright (c) (2014-2019,2021-2023) Apple Inc. All rights reserved.
 *
 * corecrypto is licensed under Apple Inc.â€™s Internal Use License Agreement (which
 * is contained in the License.txt file distributed with corecrypto) and only to
 * people who accept that license. IMPORTANT:  Any license rights granted to you by
 * Apple Inc. (if any) are limited to internal use within your organization only on
 * devices and computers you own or control, for the sole purpose of verifying the
 * security characteristics and correct functioning of the Apple Software.  You may
 * not, directly or indirectly, redistribute the Apple Software or any portions thereof.
 */

/*
    Based on reference code from <http://ed25519.cr.yp.to/> and <http://bench.cr.yp.to/supercop.html>.
*/

#include "cc_internal.h"
#include <corecrypto/ccec25519.h>
#include <corecrypto/ccdigest.h>
#include <corecrypto/ccsha2.h>
#include "ccrng_internal.h"
#include <corecrypto/ccec25519_priv.h>
#include "cced25519_internal.h"
#include "cc_priv.h"

/*!
    @function cced25519_sign_internal
    @abstract Produces an (optionally randomized) Ed25519 signature.

    @param  di          A valid descriptor for a 512 bit hash function for the platform
    @param  rng         RNG for masking.
    @param  sig         Receives the 64-byte signature.
    @param  mlen        Number of bytes to sign.
    @param  inMsg       Data to sign.
    @param  pk          32-byte public key as generated by cced25519_make_key_pair().
    @param  sk          32-byte secret key as generated by cced25519_make_key_pair().
    @param  Z           32 bytes of randomness to prefix the private key (optional).
                        Pass all zeros for deterministic signatures.
*/
CC_NONNULL((1, 2, 3, 5, 6, 7))
static int cced25519_sign_internal(const struct ccdigest_info *di,
                                   struct ccrng_state *rng,
                                   ccec25519signature sig,
                                   size_t mlen,
                                   const void *inMsg,
                                   const ccec25519pubkey pk,
                                   const ccec25519secretkey sk,
                                   const uint8_t *Z)
{
    const uint8_t *const m = (const uint8_t *)inMsg;
    uint8_t az[64];
    uint8_t r[64];
    uint8_t hram[64];
    ge_p3 R;

    cc_require_or_return(di->output_size == 64, CCERR_PARAMETER);
    cc_require_or_return(di->block_size == 128, CCERR_PARAMETER);

    ccdigest(di, 32, sk, az);
    az[0] &= 248;
    az[31] &= 63;
    az[31] |= 64;

    ccdigest_di_decl(di, dc);
    ccdigest_init(di, dc);

    // Randomize the signature.
    // See https://datatracker.ietf.org/doc/html/draft-mattsson-cfrg-det-sigs-with-noise-04.
    if (Z) {
        const uint8_t pad[64] = { 0 };
        ccdigest_update(di, dc, 32, Z);
        ccdigest_update(di, dc, sizeof(pad), pad);
    }

    ccdigest_update(di, dc, 32, az + 32);
    // Ensure we filled a full input block.
    cc_require_or_return((Z == NULL) || (ccdigest_num(di, dc) == 0), CCERR_INTERNAL);

    ccdigest_update(di, dc, mlen, m);
    ccdigest_final(di, dc, r);
    ccdigest_di_clear(di, dc);

    sc_reduce(r);
    int rv = ge_scalarmult_base_masked(&R, r, rng);
    if (rv) {
        goto err;
    }
    ge_p3_tobytes(sig, &R);

    ccdigest_init(di, dc);
    ccdigest_update(di, dc, 32, sig);
    ccdigest_update(di, dc, 32, pk);
    ccdigest_update(di, dc, mlen, m);
    ccdigest_final(di, dc, hram);
    ccdigest_di_clear(di, dc);

    sc_reduce(hram);
    sc_muladd(sig + 32, hram, az, r);

err:
    cc_clear(sizeof(az), az);
    return rv;
}

int cced25519_sign_with_rng(const struct ccdigest_info *di,
                            struct ccrng_state *rng,
                            ccec25519signature sig,
                            size_t len,
                            const void *msg,
                            const ccec25519pubkey pk,
                            const ccec25519secretkey sk)
{
    CC_ENSURE_DIT_ENABLED

    uint8_t Z[32];
    int rv = ccrng_generate_fips(rng, sizeof(Z), Z);
    cc_require_or_return(rv == CCERR_OK, rv);

    ccec25519pubkey pk_computed;
    rv = cced25519_make_pub_with_rng(ccsha512_di(), rng, pk_computed, sk);
    cc_require_or_return(rv == CCERR_OK, rv);

    if (cc_memcmp(pk, pk_computed, sizeof(ccec25519pubkey)) != 0) {
        cc_clear(sizeof(ccec25519signature), sig);
        return CCERR_PARAMETER;
    }

    return cced25519_sign_internal(di, rng, sig, len, msg, pk, sk, Z);
}

int cced25519_sign(const struct ccdigest_info *di,
                   ccec25519signature sig,
                   size_t len,
                   const void *msg,
                   const ccec25519pubkey pk,
                   const ccec25519secretkey sk)
{
    CC_ENSURE_DIT_ENABLED

    struct ccrng_state *rng = ccrng(NULL);
    cc_require_or_return(rng, CCERR_INTERNAL);

    return cced25519_sign_with_rng(di, rng, sig, len, msg, pk, sk);
}

int cced25519_sign_deterministic(const struct ccdigest_info *di,
                                 struct ccrng_state *rng,
                                 ccec25519signature sig,
                                 size_t msg_len,
                                 const void *msg,
                                 const ccec25519pubkey pk,
                                 const ccec25519secretkey sk)
{
    return cced25519_sign_internal(di, rng, sig, msg_len, msg, pk, sk, NULL);
}
